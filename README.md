Сложный момент - тип оплаты, вопрос как он влияет на подсчет стоимости корзины, где и в каком виде расположены
данные о типах оплаты. Это может потребовать серьезного рефакторинга, так как точно неизвестна область ответственности 
сервиса с этой стороны.

~~Мое личное видение, что расчет, тип оплаты и отправка заказа (то что касается адреса), стоит декомпозировать, 
хотя это уже сильно зависит от остальной системы.~~ Иначе сервисный класс должен быть осведомлен, что требуется сделать с
адресом и типом оплаты, например применение каких-то зависящих от этого параметра скидок.

В эндпоинте используется id типа int, что довольно нестандартно. Есть подозрение, что это может поменяться и, вероятно,
стоит применить дженирики или выделить id в самостоятельный объект, хотя в целом момент сложный, так как id параметры 
проходят через все рабочие классы сервиса.

Для числовых значений цен и стоимостей может потребоваться заменить float на BigDecimal для точных подсчетов и
округлений.

Было бы здорово сделать асинхронным получение продуктов из ProductDAO.

Клиент к внешнему микросервису сделан в виде интерфейса. Однако мне ничего неизвестно об апи этого сервиса, поэтому
стоит сделать контракт более абстрактным, ограничив его только связкой id-цена. Используемый класс Product - мое
предположение, о возможностях оного сервиса.

Конфигурация кэша вынесена в класс CacheConfig для возможности подключения в будущем внешнего решения для кэширования,
например Redis.

Нужна валидация входных данных

Разделить корзину и подсчитанную корзину, между ними не требуется наследования.